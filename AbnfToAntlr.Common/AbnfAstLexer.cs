//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 AbnfAst.g3 2020-01-04 12:59:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class AbnfAstLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ALTERNATION_NODE=4;
	public const int ASTERISK=5;
	public const int BIN_VAL_CONCAT_NODE=6;
	public const int BIN_VAL_NODE=7;
	public const int BIN_VAL_NUMBER_NODE=8;
	public const int BIN_VAL_PREFIX=9;
	public const int BIN_VAL_RANGE_NODE=10;
	public const int CASE_INSENSITIVE_STRING_NODE=11;
	public const int CASE_SENSITIVE_STRING_NODE=12;
	public const int CHAR_VAL_NODE=13;
	public const int COMMENT=14;
	public const int CONCATENATION_NODE=15;
	public const int CR=16;
	public const int CRLF=17;
	public const int DASH=18;
	public const int DEC_VAL_CONCAT_NODE=19;
	public const int DEC_VAL_NODE=20;
	public const int DEC_VAL_NUMBER_NODE=21;
	public const int DEC_VAL_PREFIX=22;
	public const int DEC_VAL_RANGE_NODE=23;
	public const int DEFINED_AS_NODE=24;
	public const int DQUOTE=25;
	public const int EXACT_OCCURENCES=26;
	public const int GROUP_NODE=27;
	public const int HEX_ALPHA=28;
	public const int HEX_VAL_CONCAT_NODE=29;
	public const int HEX_VAL_NODE=30;
	public const int HEX_VAL_NUMBER_NODE=31;
	public const int HEX_VAL_PREFIX=32;
	public const int HEX_VAL_RANGE_NODE=33;
	public const int HTAB=34;
	public const int LF=35;
	public const int NUMBER_NODE=36;
	public const int ONE=37;
	public const int ONE_OCCURENCE=38;
	public const int OPTION_NODE=39;
	public const int ORMORE_OCCURENCES=40;
	public const int OTHER_ALPHA=41;
	public const int OTHER_DIGIT=42;
	public const int PROSE_VAL=43;
	public const int PROSE_VAL_NODE=44;
	public const int QUOTE=45;
	public const int QUOTED_STRING=46;
	public const int REPEAT_NODE=47;
	public const int REPETITION_NODE=48;
	public const int RULE_LIST_NODE=49;
	public const int RULE_NAME_NODE=50;
	public const int RULE_NODE=51;
	public const int SINGLE_QUOTED_STRING=52;
	public const int SP=53;
	public const int VCHAR=54;
	public const int WSP=55;
	public const int ZERO=56;
	public const int ZERO_OCCURENCES=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;

	// delegates
	// delegators

	public AbnfAstLexer()
	{
		OnCreated();
	}

	public AbnfAstLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public AbnfAstLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "AbnfAst.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__58();
	partial void LeaveRule_T__58();

	// $ANTLR start "T__58"
	[GrammarRule("T__58")]
	private void mT__58()
	{
		EnterRule_T__58();
		EnterRule("T__58", 1);
		TraceIn("T__58", 1);
		try
		{
			int _type = T__58;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:8:7: ( '%i' )
			DebugEnterAlt(1);
			// AbnfAst.g3:8:9: '%i'
			{
			DebugLocation(8, 9);
			Match("%i"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__58", 1);
			LeaveRule("T__58", 1);
			LeaveRule_T__58();
		}
	}
	// $ANTLR end "T__58"

	partial void EnterRule_T__59();
	partial void LeaveRule_T__59();

	// $ANTLR start "T__59"
	[GrammarRule("T__59")]
	private void mT__59()
	{
		EnterRule_T__59();
		EnterRule("T__59", 2);
		TraceIn("T__59", 2);
		try
		{
			int _type = T__59;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:9:7: ( '%s' )
			DebugEnterAlt(1);
			// AbnfAst.g3:9:9: '%s'
			{
			DebugLocation(9, 9);
			Match("%s"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__59", 2);
			LeaveRule("T__59", 2);
			LeaveRule_T__59();
		}
	}
	// $ANTLR end "T__59"

	partial void EnterRule_T__60();
	partial void LeaveRule_T__60();

	// $ANTLR start "T__60"
	[GrammarRule("T__60")]
	private void mT__60()
	{
		EnterRule_T__60();
		EnterRule("T__60", 3);
		TraceIn("T__60", 3);
		try
		{
			int _type = T__60;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:10:7: ( '(' )
			DebugEnterAlt(1);
			// AbnfAst.g3:10:9: '('
			{
			DebugLocation(10, 9);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__60", 3);
			LeaveRule("T__60", 3);
			LeaveRule_T__60();
		}
	}
	// $ANTLR end "T__60"

	partial void EnterRule_T__61();
	partial void LeaveRule_T__61();

	// $ANTLR start "T__61"
	[GrammarRule("T__61")]
	private void mT__61()
	{
		EnterRule_T__61();
		EnterRule("T__61", 4);
		TraceIn("T__61", 4);
		try
		{
			int _type = T__61;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:11:7: ( ')' )
			DebugEnterAlt(1);
			// AbnfAst.g3:11:9: ')'
			{
			DebugLocation(11, 9);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__61", 4);
			LeaveRule("T__61", 4);
			LeaveRule_T__61();
		}
	}
	// $ANTLR end "T__61"

	partial void EnterRule_T__62();
	partial void LeaveRule_T__62();

	// $ANTLR start "T__62"
	[GrammarRule("T__62")]
	private void mT__62()
	{
		EnterRule_T__62();
		EnterRule("T__62", 5);
		TraceIn("T__62", 5);
		try
		{
			int _type = T__62;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:12:7: ( '.' )
			DebugEnterAlt(1);
			// AbnfAst.g3:12:9: '.'
			{
			DebugLocation(12, 9);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__62", 5);
			LeaveRule("T__62", 5);
			LeaveRule_T__62();
		}
	}
	// $ANTLR end "T__62"

	partial void EnterRule_T__63();
	partial void LeaveRule_T__63();

	// $ANTLR start "T__63"
	[GrammarRule("T__63")]
	private void mT__63()
	{
		EnterRule_T__63();
		EnterRule("T__63", 6);
		TraceIn("T__63", 6);
		try
		{
			int _type = T__63;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:13:7: ( '/' )
			DebugEnterAlt(1);
			// AbnfAst.g3:13:9: '/'
			{
			DebugLocation(13, 9);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__63", 6);
			LeaveRule("T__63", 6);
			LeaveRule_T__63();
		}
	}
	// $ANTLR end "T__63"

	partial void EnterRule_T__64();
	partial void LeaveRule_T__64();

	// $ANTLR start "T__64"
	[GrammarRule("T__64")]
	private void mT__64()
	{
		EnterRule_T__64();
		EnterRule("T__64", 7);
		TraceIn("T__64", 7);
		try
		{
			int _type = T__64;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:14:7: ( '=' )
			DebugEnterAlt(1);
			// AbnfAst.g3:14:9: '='
			{
			DebugLocation(14, 9);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__64", 7);
			LeaveRule("T__64", 7);
			LeaveRule_T__64();
		}
	}
	// $ANTLR end "T__64"

	partial void EnterRule_T__65();
	partial void LeaveRule_T__65();

	// $ANTLR start "T__65"
	[GrammarRule("T__65")]
	private void mT__65()
	{
		EnterRule_T__65();
		EnterRule("T__65", 8);
		TraceIn("T__65", 8);
		try
		{
			int _type = T__65;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:15:7: ( '=/' )
			DebugEnterAlt(1);
			// AbnfAst.g3:15:9: '=/'
			{
			DebugLocation(15, 9);
			Match("=/"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__65", 8);
			LeaveRule("T__65", 8);
			LeaveRule_T__65();
		}
	}
	// $ANTLR end "T__65"

	partial void EnterRule_T__66();
	partial void LeaveRule_T__66();

	// $ANTLR start "T__66"
	[GrammarRule("T__66")]
	private void mT__66()
	{
		EnterRule_T__66();
		EnterRule("T__66", 9);
		TraceIn("T__66", 9);
		try
		{
			int _type = T__66;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:16:7: ( '[' )
			DebugEnterAlt(1);
			// AbnfAst.g3:16:9: '['
			{
			DebugLocation(16, 9);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__66", 9);
			LeaveRule("T__66", 9);
			LeaveRule_T__66();
		}
	}
	// $ANTLR end "T__66"

	partial void EnterRule_T__67();
	partial void LeaveRule_T__67();

	// $ANTLR start "T__67"
	[GrammarRule("T__67")]
	private void mT__67()
	{
		EnterRule_T__67();
		EnterRule("T__67", 10);
		TraceIn("T__67", 10);
		try
		{
			int _type = T__67;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:17:7: ( ']' )
			DebugEnterAlt(1);
			// AbnfAst.g3:17:9: ']'
			{
			DebugLocation(17, 9);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__67", 10);
			LeaveRule("T__67", 10);
			LeaveRule_T__67();
		}
	}
	// $ANTLR end "T__67"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 11);
		TraceIn("COMMENT", 11);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:288:2: ( ';' ( WSP | VCHAR )* CRLF )
			DebugEnterAlt(1);
			// AbnfAst.g3:289:3: ';' ( WSP | VCHAR )* CRLF
			{
			DebugLocation(289, 3);
			Match(';'); 
			DebugLocation(289, 7);
			// AbnfAst.g3:289:7: ( WSP | VCHAR )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=3;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1=='\t'||LA1_1==' '))
				{
					alt1 = 1;
				}
				else if (((LA1_1>='!' && LA1_1<='~')))
				{
					alt1 = 2;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g3:289:9: WSP
					{
					DebugLocation(289, 9);
					mWSP(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AbnfAst.g3:289:15: VCHAR
					{
					DebugLocation(289, 15);
					mVCHAR(); 

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(289, 24);
			mCRLF(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 11);
			LeaveRule("COMMENT", 11);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_BIN_VAL_PREFIX();
	partial void LeaveRule_BIN_VAL_PREFIX();

	// $ANTLR start "BIN_VAL_PREFIX"
	[GrammarRule("BIN_VAL_PREFIX")]
	private void mBIN_VAL_PREFIX()
	{
		EnterRule_BIN_VAL_PREFIX();
		EnterRule("BIN_VAL_PREFIX", 12);
		TraceIn("BIN_VAL_PREFIX", 12);
		try
		{
			int _type = BIN_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:293:2: ( '%b' )
			DebugEnterAlt(1);
			// AbnfAst.g3:294:3: '%b'
			{
			DebugLocation(294, 3);
			Match("%b"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIN_VAL_PREFIX", 12);
			LeaveRule("BIN_VAL_PREFIX", 12);
			LeaveRule_BIN_VAL_PREFIX();
		}
	}
	// $ANTLR end "BIN_VAL_PREFIX"

	partial void EnterRule_DEC_VAL_PREFIX();
	partial void LeaveRule_DEC_VAL_PREFIX();

	// $ANTLR start "DEC_VAL_PREFIX"
	[GrammarRule("DEC_VAL_PREFIX")]
	private void mDEC_VAL_PREFIX()
	{
		EnterRule_DEC_VAL_PREFIX();
		EnterRule("DEC_VAL_PREFIX", 13);
		TraceIn("DEC_VAL_PREFIX", 13);
		try
		{
			int _type = DEC_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:298:2: ( '%d' )
			DebugEnterAlt(1);
			// AbnfAst.g3:299:3: '%d'
			{
			DebugLocation(299, 3);
			Match("%d"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEC_VAL_PREFIX", 13);
			LeaveRule("DEC_VAL_PREFIX", 13);
			LeaveRule_DEC_VAL_PREFIX();
		}
	}
	// $ANTLR end "DEC_VAL_PREFIX"

	partial void EnterRule_HEX_VAL_PREFIX();
	partial void LeaveRule_HEX_VAL_PREFIX();

	// $ANTLR start "HEX_VAL_PREFIX"
	[GrammarRule("HEX_VAL_PREFIX")]
	private void mHEX_VAL_PREFIX()
	{
		EnterRule_HEX_VAL_PREFIX();
		EnterRule("HEX_VAL_PREFIX", 14);
		TraceIn("HEX_VAL_PREFIX", 14);
		try
		{
			int _type = HEX_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:303:2: ( '%x' )
			DebugEnterAlt(1);
			// AbnfAst.g3:304:3: '%x'
			{
			DebugLocation(304, 3);
			Match("%x"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_VAL_PREFIX", 14);
			LeaveRule("HEX_VAL_PREFIX", 14);
			LeaveRule_HEX_VAL_PREFIX();
		}
	}
	// $ANTLR end "HEX_VAL_PREFIX"

	partial void EnterRule_PROSE_VAL();
	partial void LeaveRule_PROSE_VAL();

	// $ANTLR start "PROSE_VAL"
	[GrammarRule("PROSE_VAL")]
	private void mPROSE_VAL()
	{
		EnterRule_PROSE_VAL();
		EnterRule("PROSE_VAL", 15);
		TraceIn("PROSE_VAL", 15);
		try
		{
			int _type = PROSE_VAL;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:308:2: ( '<' ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )* '>' )
			DebugEnterAlt(1);
			// AbnfAst.g3:309:3: '<' ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )* '>'
			{
			DebugLocation(309, 3);
			Match('<'); 
			DebugLocation(309, 7);
			// AbnfAst.g3:309:7: ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>=' ' && LA2_1<='=')||(LA2_1>='?' && LA2_1<='~')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g3:
					{
					DebugLocation(309, 7);
					input.Consume();


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(309, 52);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROSE_VAL", 15);
			LeaveRule("PROSE_VAL", 15);
			LeaveRule_PROSE_VAL();
		}
	}
	// $ANTLR end "PROSE_VAL"

	partial void EnterRule_HEX_ALPHA();
	partial void LeaveRule_HEX_ALPHA();

	// $ANTLR start "HEX_ALPHA"
	[GrammarRule("HEX_ALPHA")]
	private void mHEX_ALPHA()
	{
		EnterRule_HEX_ALPHA();
		EnterRule("HEX_ALPHA", 16);
		TraceIn("HEX_ALPHA", 16);
		try
		{
			int _type = HEX_ALPHA;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:313:2: ( 'A' .. 'F' )
			DebugEnterAlt(1);
			// AbnfAst.g3:
			{
			DebugLocation(313, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='F'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_ALPHA", 16);
			LeaveRule("HEX_ALPHA", 16);
			LeaveRule_HEX_ALPHA();
		}
	}
	// $ANTLR end "HEX_ALPHA"

	partial void EnterRule_OTHER_ALPHA();
	partial void LeaveRule_OTHER_ALPHA();

	// $ANTLR start "OTHER_ALPHA"
	[GrammarRule("OTHER_ALPHA")]
	private void mOTHER_ALPHA()
	{
		EnterRule_OTHER_ALPHA();
		EnterRule("OTHER_ALPHA", 17);
		TraceIn("OTHER_ALPHA", 17);
		try
		{
			int _type = OTHER_ALPHA;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:318:2: ( 'G' .. 'Z' | 'a' .. 'z' )
			DebugEnterAlt(1);
			// AbnfAst.g3:
			{
			DebugLocation(318, 2);
			if ((input.LA(1)>='G' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OTHER_ALPHA", 17);
			LeaveRule("OTHER_ALPHA", 17);
			LeaveRule_OTHER_ALPHA();
		}
	}
	// $ANTLR end "OTHER_ALPHA"

	partial void EnterRule_ASTERISK();
	partial void LeaveRule_ASTERISK();

	// $ANTLR start "ASTERISK"
	[GrammarRule("ASTERISK")]
	private void mASTERISK()
	{
		EnterRule_ASTERISK();
		EnterRule("ASTERISK", 18);
		TraceIn("ASTERISK", 18);
		try
		{
			int _type = ASTERISK;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:323:2: ( '*' )
			DebugEnterAlt(1);
			// AbnfAst.g3:324:3: '*'
			{
			DebugLocation(324, 3);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASTERISK", 18);
			LeaveRule("ASTERISK", 18);
			LeaveRule_ASTERISK();
		}
	}
	// $ANTLR end "ASTERISK"

	partial void EnterRule_DASH();
	partial void LeaveRule_DASH();

	// $ANTLR start "DASH"
	[GrammarRule("DASH")]
	private void mDASH()
	{
		EnterRule_DASH();
		EnterRule("DASH", 19);
		TraceIn("DASH", 19);
		try
		{
			int _type = DASH;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:328:2: ( '-' )
			DebugEnterAlt(1);
			// AbnfAst.g3:329:3: '-'
			{
			DebugLocation(329, 3);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DASH", 19);
			LeaveRule("DASH", 19);
			LeaveRule_DASH();
		}
	}
	// $ANTLR end "DASH"

	partial void EnterRule_CR();
	partial void LeaveRule_CR();

	// $ANTLR start "CR"
	[GrammarRule("CR")]
	private void mCR()
	{
		EnterRule_CR();
		EnterRule("CR", 20);
		TraceIn("CR", 20);
		try
		{
			// AbnfAst.g3:333:2: ( '\\u000D' )
			DebugEnterAlt(1);
			// AbnfAst.g3:334:3: '\\u000D'
			{
			DebugLocation(334, 3);
			Match('\r'); 

			}

		}
		finally
		{
			TraceOut("CR", 20);
			LeaveRule("CR", 20);
			LeaveRule_CR();
		}
	}
	// $ANTLR end "CR"

	partial void EnterRule_CRLF();
	partial void LeaveRule_CRLF();

	// $ANTLR start "CRLF"
	[GrammarRule("CRLF")]
	private void mCRLF()
	{
		EnterRule_CRLF();
		EnterRule("CRLF", 21);
		TraceIn("CRLF", 21);
		try
		{
			int _type = CRLF;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:339:2: ( CR LF )
			DebugEnterAlt(1);
			// AbnfAst.g3:340:3: CR LF
			{
			DebugLocation(340, 3);
			mCR(); 
			DebugLocation(340, 6);
			mLF(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CRLF", 21);
			LeaveRule("CRLF", 21);
			LeaveRule_CRLF();
		}
	}
	// $ANTLR end "CRLF"

	partial void EnterRule_ZERO();
	partial void LeaveRule_ZERO();

	// $ANTLR start "ZERO"
	[GrammarRule("ZERO")]
	private void mZERO()
	{
		EnterRule_ZERO();
		EnterRule("ZERO", 22);
		TraceIn("ZERO", 22);
		try
		{
			int _type = ZERO;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:345:2: ( '0' )
			DebugEnterAlt(1);
			// AbnfAst.g3:346:3: '0'
			{
			DebugLocation(346, 3);
			Match('0'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ZERO", 22);
			LeaveRule("ZERO", 22);
			LeaveRule_ZERO();
		}
	}
	// $ANTLR end "ZERO"

	partial void EnterRule_ONE();
	partial void LeaveRule_ONE();

	// $ANTLR start "ONE"
	[GrammarRule("ONE")]
	private void mONE()
	{
		EnterRule_ONE();
		EnterRule("ONE", 23);
		TraceIn("ONE", 23);
		try
		{
			int _type = ONE;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:350:2: ( '1' )
			DebugEnterAlt(1);
			// AbnfAst.g3:351:3: '1'
			{
			DebugLocation(351, 3);
			Match('1'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ONE", 23);
			LeaveRule("ONE", 23);
			LeaveRule_ONE();
		}
	}
	// $ANTLR end "ONE"

	partial void EnterRule_OTHER_DIGIT();
	partial void LeaveRule_OTHER_DIGIT();

	// $ANTLR start "OTHER_DIGIT"
	[GrammarRule("OTHER_DIGIT")]
	private void mOTHER_DIGIT()
	{
		EnterRule_OTHER_DIGIT();
		EnterRule("OTHER_DIGIT", 24);
		TraceIn("OTHER_DIGIT", 24);
		try
		{
			int _type = OTHER_DIGIT;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:355:2: ( '2' .. '9' )
			DebugEnterAlt(1);
			// AbnfAst.g3:
			{
			DebugLocation(355, 2);
			if ((input.LA(1)>='2' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OTHER_DIGIT", 24);
			LeaveRule("OTHER_DIGIT", 24);
			LeaveRule_OTHER_DIGIT();
		}
	}
	// $ANTLR end "OTHER_DIGIT"

	partial void EnterRule_QUOTED_STRING();
	partial void LeaveRule_QUOTED_STRING();

	// $ANTLR start "QUOTED_STRING"
	[GrammarRule("QUOTED_STRING")]
	private void mQUOTED_STRING()
	{
		EnterRule_QUOTED_STRING();
		EnterRule("QUOTED_STRING", 25);
		TraceIn("QUOTED_STRING", 25);
		try
		{
			int _type = QUOTED_STRING;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:360:2: ( DQUOTE ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )* DQUOTE )
			DebugEnterAlt(1);
			// AbnfAst.g3:361:3: DQUOTE ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )* DQUOTE
			{
			DebugLocation(361, 3);
			mDQUOTE(); 
			DebugLocation(361, 10);
			// AbnfAst.g3:361:10: ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if (((LA3_1>=' ' && LA3_1<='!')||(LA3_1>='#' && LA3_1<='~')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g3:
					{
					DebugLocation(361, 10);
					input.Consume();


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(361, 55);
			mDQUOTE(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("QUOTED_STRING", 25);
			LeaveRule("QUOTED_STRING", 25);
			LeaveRule_QUOTED_STRING();
		}
	}
	// $ANTLR end "QUOTED_STRING"

	partial void EnterRule_SINGLE_QUOTED_STRING();
	partial void LeaveRule_SINGLE_QUOTED_STRING();

	// $ANTLR start "SINGLE_QUOTED_STRING"
	[GrammarRule("SINGLE_QUOTED_STRING")]
	private void mSINGLE_QUOTED_STRING()
	{
		EnterRule_SINGLE_QUOTED_STRING();
		EnterRule("SINGLE_QUOTED_STRING", 26);
		TraceIn("SINGLE_QUOTED_STRING", 26);
		try
		{
			int _type = SINGLE_QUOTED_STRING;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:367:2: ( QUOTE ( '\\u0020' .. '\\u0026' | '\\u0028' .. '\\u007E' )* QUOTE )
			DebugEnterAlt(1);
			// AbnfAst.g3:368:3: QUOTE ( '\\u0020' .. '\\u0026' | '\\u0028' .. '\\u007E' )* QUOTE
			{
			DebugLocation(368, 3);
			mQUOTE(); 
			DebugLocation(368, 9);
			// AbnfAst.g3:368:9: ( '\\u0020' .. '\\u0026' | '\\u0028' .. '\\u007E' )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>=' ' && LA4_1<='&')||(LA4_1>='(' && LA4_1<='~')))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g3:
					{
					DebugLocation(368, 9);
					input.Consume();


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(368, 54);
			mQUOTE(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SINGLE_QUOTED_STRING", 26);
			LeaveRule("SINGLE_QUOTED_STRING", 26);
			LeaveRule_SINGLE_QUOTED_STRING();
		}
	}
	// $ANTLR end "SINGLE_QUOTED_STRING"

	partial void EnterRule_QUOTE();
	partial void LeaveRule_QUOTE();

	// $ANTLR start "QUOTE"
	[GrammarRule("QUOTE")]
	private void mQUOTE()
	{
		EnterRule_QUOTE();
		EnterRule("QUOTE", 27);
		TraceIn("QUOTE", 27);
		try
		{
			// AbnfAst.g3:374:2: ( '\\'' )
			DebugEnterAlt(1);
			// AbnfAst.g3:375:3: '\\''
			{
			DebugLocation(375, 3);
			Match('\''); 

			}

		}
		finally
		{
			TraceOut("QUOTE", 27);
			LeaveRule("QUOTE", 27);
			LeaveRule_QUOTE();
		}
	}
	// $ANTLR end "QUOTE"

	partial void EnterRule_DQUOTE();
	partial void LeaveRule_DQUOTE();

	// $ANTLR start "DQUOTE"
	[GrammarRule("DQUOTE")]
	private void mDQUOTE()
	{
		EnterRule_DQUOTE();
		EnterRule("DQUOTE", 28);
		TraceIn("DQUOTE", 28);
		try
		{
			// AbnfAst.g3:380:2: ( '\\u0022' )
			DebugEnterAlt(1);
			// AbnfAst.g3:381:3: '\\u0022'
			{
			DebugLocation(381, 3);
			Match('\"'); 

			}

		}
		finally
		{
			TraceOut("DQUOTE", 28);
			LeaveRule("DQUOTE", 28);
			LeaveRule_DQUOTE();
		}
	}
	// $ANTLR end "DQUOTE"

	partial void EnterRule_HTAB();
	partial void LeaveRule_HTAB();

	// $ANTLR start "HTAB"
	[GrammarRule("HTAB")]
	private void mHTAB()
	{
		EnterRule_HTAB();
		EnterRule("HTAB", 29);
		TraceIn("HTAB", 29);
		try
		{
			// AbnfAst.g3:386:2: ( '\\u0009' )
			DebugEnterAlt(1);
			// AbnfAst.g3:387:3: '\\u0009'
			{
			DebugLocation(387, 3);
			Match('\t'); 

			}

		}
		finally
		{
			TraceOut("HTAB", 29);
			LeaveRule("HTAB", 29);
			LeaveRule_HTAB();
		}
	}
	// $ANTLR end "HTAB"

	partial void EnterRule_LF();
	partial void LeaveRule_LF();

	// $ANTLR start "LF"
	[GrammarRule("LF")]
	private void mLF()
	{
		EnterRule_LF();
		EnterRule("LF", 30);
		TraceIn("LF", 30);
		try
		{
			// AbnfAst.g3:392:2: ( '\\u000A' )
			DebugEnterAlt(1);
			// AbnfAst.g3:393:3: '\\u000A'
			{
			DebugLocation(393, 3);
			Match('\n'); 

			}

		}
		finally
		{
			TraceOut("LF", 30);
			LeaveRule("LF", 30);
			LeaveRule_LF();
		}
	}
	// $ANTLR end "LF"

	partial void EnterRule_SP();
	partial void LeaveRule_SP();

	// $ANTLR start "SP"
	[GrammarRule("SP")]
	private void mSP()
	{
		EnterRule_SP();
		EnterRule("SP", 31);
		TraceIn("SP", 31);
		try
		{
			// AbnfAst.g3:398:2: ( '\\u0020' )
			DebugEnterAlt(1);
			// AbnfAst.g3:399:3: '\\u0020'
			{
			DebugLocation(399, 3);
			Match(' '); 

			}

		}
		finally
		{
			TraceOut("SP", 31);
			LeaveRule("SP", 31);
			LeaveRule_SP();
		}
	}
	// $ANTLR end "SP"

	partial void EnterRule_VCHAR();
	partial void LeaveRule_VCHAR();

	// $ANTLR start "VCHAR"
	[GrammarRule("VCHAR")]
	private void mVCHAR()
	{
		EnterRule_VCHAR();
		EnterRule("VCHAR", 32);
		TraceIn("VCHAR", 32);
		try
		{
			// AbnfAst.g3:404:2: ( '\\u0021' .. '\\u007E' )
			DebugEnterAlt(1);
			// AbnfAst.g3:
			{
			DebugLocation(404, 2);
			if ((input.LA(1)>='!' && input.LA(1)<='~'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("VCHAR", 32);
			LeaveRule("VCHAR", 32);
			LeaveRule_VCHAR();
		}
	}
	// $ANTLR end "VCHAR"

	partial void EnterRule_WSP();
	partial void LeaveRule_WSP();

	// $ANTLR start "WSP"
	[GrammarRule("WSP")]
	private void mWSP()
	{
		EnterRule_WSP();
		EnterRule("WSP", 33);
		TraceIn("WSP", 33);
		try
		{
			int _type = WSP;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g3:410:2: ( ( SP | HTAB )+ )
			DebugEnterAlt(1);
			// AbnfAst.g3:411:3: ( SP | HTAB )+
			{
			DebugLocation(411, 3);
			// AbnfAst.g3:411:3: ( SP | HTAB )+
			int cnt5=0;
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1=='\t'||LA5_1==' '))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g3:
					{
					DebugLocation(411, 3);
					input.Consume();


					}
					break;

				default:
					if (cnt5 >= 1)
						goto loop5;

					EarlyExitException eee5 = new EarlyExitException( 5, input );
					DebugRecognitionException(eee5);
					throw eee5;
				}
				cnt5++;
			}
			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WSP", 33);
			LeaveRule("WSP", 33);
			LeaveRule_WSP();
		}
	}
	// $ANTLR end "WSP"

	public override void mTokens()
	{
		// AbnfAst.g3:1:8: ( T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | COMMENT | BIN_VAL_PREFIX | DEC_VAL_PREFIX | HEX_VAL_PREFIX | PROSE_VAL | HEX_ALPHA | OTHER_ALPHA | ASTERISK | DASH | CRLF | ZERO | ONE | OTHER_DIGIT | QUOTED_STRING | SINGLE_QUOTED_STRING | WSP )
		int alt6=26;
		try { DebugEnterDecision(6, false);
		switch (input.LA(1))
		{
		case '%':
			{
			switch (input.LA(2))
			{
			case 'i':
				{
				alt6 = 1;
				}
				break;
			case 's':
				{
				alt6 = 2;
				}
				break;
			case 'b':
				{
				alt6 = 12;
				}
				break;
			case 'd':
				{
				alt6 = 13;
				}
				break;
			case 'x':
				{
				alt6 = 14;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			}
			break;
		case '(':
			{
			alt6 = 3;
			}
			break;
		case ')':
			{
			alt6 = 4;
			}
			break;
		case '.':
			{
			alt6 = 5;
			}
			break;
		case '/':
			{
			alt6 = 6;
			}
			break;
		case '=':
			{
			int LA6_2 = input.LA(2);

			if ((LA6_2=='/'))
			{
				alt6 = 8;
			}
			else
			{
				alt6 = 7;
			}
			}
			break;
		case '[':
			{
			alt6 = 9;
			}
			break;
		case ']':
			{
			alt6 = 10;
			}
			break;
		case ';':
			{
			alt6 = 11;
			}
			break;
		case '<':
			{
			alt6 = 15;
			}
			break;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			{
			alt6 = 16;
			}
			break;
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
			{
			alt6 = 17;
			}
			break;
		case '*':
			{
			alt6 = 18;
			}
			break;
		case '-':
			{
			alt6 = 19;
			}
			break;
		case '\r':
			{
			alt6 = 20;
			}
			break;
		case '0':
			{
			alt6 = 21;
			}
			break;
		case '1':
			{
			alt6 = 22;
			}
			break;
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt6 = 23;
			}
			break;
		case '\"':
			{
			alt6 = 24;
			}
			break;
		case '\'':
			{
			alt6 = 25;
			}
			break;
		case '\t':
		case ' ':
			{
			alt6 = 26;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(6); }
		switch (alt6)
		{
		case 1:
			DebugEnterAlt(1);
			// AbnfAst.g3:1:10: T__58
			{
			DebugLocation(1, 10);
			mT__58(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// AbnfAst.g3:1:16: T__59
			{
			DebugLocation(1, 16);
			mT__59(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// AbnfAst.g3:1:22: T__60
			{
			DebugLocation(1, 22);
			mT__60(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// AbnfAst.g3:1:28: T__61
			{
			DebugLocation(1, 28);
			mT__61(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// AbnfAst.g3:1:34: T__62
			{
			DebugLocation(1, 34);
			mT__62(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// AbnfAst.g3:1:40: T__63
			{
			DebugLocation(1, 40);
			mT__63(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// AbnfAst.g3:1:46: T__64
			{
			DebugLocation(1, 46);
			mT__64(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// AbnfAst.g3:1:52: T__65
			{
			DebugLocation(1, 52);
			mT__65(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// AbnfAst.g3:1:58: T__66
			{
			DebugLocation(1, 58);
			mT__66(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// AbnfAst.g3:1:64: T__67
			{
			DebugLocation(1, 64);
			mT__67(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// AbnfAst.g3:1:70: COMMENT
			{
			DebugLocation(1, 70);
			mCOMMENT(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// AbnfAst.g3:1:78: BIN_VAL_PREFIX
			{
			DebugLocation(1, 78);
			mBIN_VAL_PREFIX(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// AbnfAst.g3:1:93: DEC_VAL_PREFIX
			{
			DebugLocation(1, 93);
			mDEC_VAL_PREFIX(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// AbnfAst.g3:1:108: HEX_VAL_PREFIX
			{
			DebugLocation(1, 108);
			mHEX_VAL_PREFIX(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// AbnfAst.g3:1:123: PROSE_VAL
			{
			DebugLocation(1, 123);
			mPROSE_VAL(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// AbnfAst.g3:1:133: HEX_ALPHA
			{
			DebugLocation(1, 133);
			mHEX_ALPHA(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// AbnfAst.g3:1:143: OTHER_ALPHA
			{
			DebugLocation(1, 143);
			mOTHER_ALPHA(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// AbnfAst.g3:1:155: ASTERISK
			{
			DebugLocation(1, 155);
			mASTERISK(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// AbnfAst.g3:1:164: DASH
			{
			DebugLocation(1, 164);
			mDASH(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// AbnfAst.g3:1:169: CRLF
			{
			DebugLocation(1, 169);
			mCRLF(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// AbnfAst.g3:1:174: ZERO
			{
			DebugLocation(1, 174);
			mZERO(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// AbnfAst.g3:1:179: ONE
			{
			DebugLocation(1, 179);
			mONE(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// AbnfAst.g3:1:183: OTHER_DIGIT
			{
			DebugLocation(1, 183);
			mOTHER_DIGIT(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// AbnfAst.g3:1:195: QUOTED_STRING
			{
			DebugLocation(1, 195);
			mQUOTED_STRING(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// AbnfAst.g3:1:209: SINGLE_QUOTED_STRING
			{
			DebugLocation(1, 209);
			mSINGLE_QUOTED_STRING(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// AbnfAst.g3:1:230: WSP
			{
			DebugLocation(1, 230);
			mWSP(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}
